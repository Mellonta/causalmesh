\section{Proof}\label{s:appendix}
\begin{lemma}\label{lemma:cover}
$
\forall (k, v) \in S_i.\textit{\white{}}, \forall j, \\
S_j.\textit{\white{}}[k].vc \ge v.vc \lor v.vc \in S_j.\textit{\black{}}[k]
$
\end{lemma}

Lemma~\ref{lemma:cover} says a write $w$ in cache server's \white{} implies on other servers it's either merged into \white{} or exists in \black{}.

\begin{proof}
When $i = j$, it is trivial. w.l.o.g., let $i$ be 2 and $j$ be 1.

$(k, vc)$ has two sources
\begin{myenumerate2}
    \item if Someone writes $w$ to $S_1$, and get passed $S_1.\textit{\black{}} \to S_2.\textit{\white{}}$,
      then it must either exist in $S_1.\textit{\black{}}$ or get merged into $S_1.\textit{\white{}}$.
    \item it's integrated from $S_2.\textit{\black{}} \to S_2.\textit{\white{}}$, then it must be
      read by some clients other than its writer. As a client reads from \white{}, $w$ has been
      propagated to all cache servers, including $S_1$.
\end{myenumerate2}
\end{proof}

\begin{lemma}\label{lemma:depsexist}
$\forall w \in S_i.\textit{\black{}} \cup S_i.\textit{\white{}}, \forall w' \in w.deps,$
$S_i.\textit{\white{}}[w'.key].vc \ge w'.vc \lor w' \in S_i.\textit{\black{}}$
\end{lemma}

Lemma~\ref{lemma:depsexist} says during integration, all dependencies can be found.
\begin{proof}
$w'$ has two sources
\begin{myenumerate2}
\item $w$ and $w'$ are written by the same client. If $w$ is come from predecessor, as the channel between servers are FIFO, $w'$ must arrive before $w$. If $w$ is from client, as the client piggybacks its own writes after migration. $w'$ is always available on the new server.
\item $w$ and $w'$ have different writers. To be in $w.deps$, $w'$ or some write depends on it must be read, which implies $w'$ have been propagated to all servers, including $S_i$.
\end{myenumerate2}
\end{proof}



\begin{lemma}[A cache server's \white{} is a cut]\label{lemma:whitecut}
\end{lemma}
\begin{proof}
We prove this by induction.
\paragraph{Base Case:} \white{} is initially empty, so it's a cut.
\paragraph{Inductive step:} Assume \white{} is a strict causal cut. \white{} changes when
\begin{myenumerate2}
\item it receives a read from client
\item it receives a write from predecessor and it's the tail
\end{myenumerate2}
In both cases, it integrates the dependencies, according to Lemma~\ref{lemma:depsexist},  \white{} is still a cut.
\end{proof}

\begin{theorem}[Read transaction returns causally-consistent view of multiple keys]\label{lemma:txn}
\end{theorem}
\begin{proof}
Directly from Lemma~\ref{lemma:whitecut}.
\end{proof}

\begin{definition}
$S \cap C$ is defined as a subset of $S$ that only consists of keys and
dependencies that overlap with $C$'s \textit{deps}.
\end{definition}


\begin{theorem}
When a client $C$ tries to read from $S_i$, $(S_i \cap C) \cup C.local$ is a cut and it covers $C.local \cup C.deps$.
\end{theorem}
\begin{proof}
According to Lemma~\ref{lemma:whitecut}, $(S_i \cap C)$ is a cut. After merging with \textit{local}, it remains a cut. As $S_i$ integrates clients' dependencies upon read requests, the cut always covers $C.local \cup C.deps$.
\end{proof}
